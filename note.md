# java 基础
1. jdk包含jre，jre中包含jvm。jdk比jre主要多编译器javac，此外还有一些javadoc、jdb（java调试器，形式为命令行）等工具。  
使用jsp部署web需要jdk，因为jsp转换为java servlet时需要编译。
2. java和c++。内存回收自动/手动，类单继承/多继承。
3. 重写方法时返回值可以是原方法返回值的子类。
4. 继承，子类拥有父类的私有属性和方法但无法访问，只能通过非私有方法访问。
5. 多态，两种体现形式：多个子类对父类同一方法多种重写，对接口中同一方法多种实现。
6. StringBuilder线程不安全，没有对方法加同步锁，比StringBuffer高10%左右性能。和StringBuffer同时继承自AbstractStringBuilder。
7. int->Integer 装箱，自动调用valueOf(int)方法；Integer->int 拆箱，intValue方法。上述方法全写在了包装器（如Integer中）。
8. 静态方法可以调用其他静态方法，不能直接调用非静态成员，需要先new一个相关对象。  
***（Q：对static内存加载的详细理解）***  
static修饰的变量存放在栈内存，没有static修饰的属于该类的实例放在堆内存。  
***（Q：堆内存和栈内存的区别）***  

9. 从设计层⾯来说，抽象是对类的抽象，是⼀种模板设计，⽽接⼝是对⾏为的抽象，是⼀种⾏为的规范。
10. uncheck Exception、Exception、RuntimeException   
    Throwable->Exception->RuntimeException
11. 无论是否有异常finally都会执行，如果try或catch中有return那么finally会在返回之前被执行。
12. transient  
    对于不想进⾏序列化的变量，使⽤ transient 关键字修饰。  
    阻⽌实例中那些⽤此关键字修饰的的变量序列化；当对象被反序列化时，被 transient 修饰的变量值不会被持久化和恢复。  
    transient 只能修饰变量，不能修饰类和⽅法。
13. Scanner、BufferedReader
14. IO
    输⼊流和输出流  
    字节流和字符流  
    节点流和处理流 节点流：可以从或向一个特定的地方（节点）读写数据，如FileReader。处理流：是对一个已存在的流的连接和封装，通过所封装的流的功能调用实现数据读写，构造方法总是要带一个其他的流对象做参数，如BufferedReader  
    InputStream/Reader 输入字节/字符流  
    OutputStream/Writer 输出字节/字符流
15. BIO,NIO,AIO  
    同步阻塞，同步非阻塞，异步非阻塞
    **p52 年轻人回头记得再仔细看看**
16. 浅拷贝，传递引用；深拷贝，创建新对象并复制内容。

# java 集合
1. List、Map、Set
2. ArrayList *    
   底层使用Object数组。  
   add，默认表尾，O(1)；  
   指定位置i则O(n-i)。  
   高效随机访问，实现了RandomAccess接口。  
   list结尾会预留一定的空间容量。  
   线程不安全。  
   Vector也是用Object[]实现的，但是线程安全极其古老。
   ***具体实现可以看一下源码（随机访问、扩容机制）***
3. LinkedList  
   底层使用双向链表（1.6之前为循环链表）。  
   查找i耗时O(n)，具体插入删除O(1)。  
   需要存放前驱后继信息。  
   未实现RandomAccess接口。  
   * 在Arrays的binarySearch()方法中会判断是否为RandomAccess实例，如果是，调⽤ indexedBinarySearch() ⽅法，如果不是，那么调⽤ iteratorBinarySearch() ⽅法
4. HashMap *  
   线程不安全，想要安全使用ConcuerrentHashMap  
   默认打算小为16，每次扩容变成原来的2倍，总是使用2的幂来作为大小  
   数组长度大于64且链表长度大于8之后，链表转化为红黑树  
   ***可以再复习一下红黑树***  
   下标为 (n-1)&hash，hash%length==hash&(length-1)的前提 是 length 是2的 n 次⽅  

5. ConcurrentHashMap  
   线程安全  
   jdk1.7 分段锁  
   jdk1.8 数据结构与HashMap相似，synchronized只锁当前链表或红黑树的首节点  
   ***synchronized锁，回头看一下***  
6. HashSet  
   底层由HashMap实现

# 多线程
1. 进程与线程的异同  
   一个进程多个线程，线程们共享进程的堆和方法区  
   线程包含：程序计数器、虚拟机栈、本地方法栈
2. 程序计数器。改变以达到代码流程控制，另一方面主要用于线程切换后能恢复到正确的执行位置。
3. 虚拟机栈。java方法调用直至执行完成，就对应着栈帧在java虚拟机中的入栈和出栈的过程。栈帧中存放局部变量、操作数栈、常量池引用等信息。  
   操作数栈可理解为java虚拟机栈中的一个用于计算的临时数据存储区  
4. 本地方法栈。与虚拟机栈相似，不过主要用于native方法。
5. 堆与方法区。堆和⽅法区是所有线程共享的资源，其中堆是进程中最⼤的⼀块内存，主要⽤于存放新创建的对象 (所有对象都在这⾥分配内存)；⽅法区主要⽤于存放已被加载的类信息、常量、静态变量、即时编译器编译后的代码等数据。
6. 多线程的好坏。  
   好：资源利用率高  
   坏：内存泄漏、上下⽂切换、死锁  
7. 线程生命周期  
   new、runnable、blocked、waiting、time_waiting、terminated
   初始、运行、阻塞、等待、超时等待、终止  
   刚刚new还没start、就绪/运行、被锁阻塞、需要其他线程的特定动作、相比普通等待到了特定时间就可以返回、已执行完毕  
8. 上下文切换。因一个cpu内核一次只能运行一个线程，需要调度。
9. 死锁。类似操作系统死锁。  
   * 互斥条件：该资源任意⼀个时刻只由⼀个线程占⽤。 
   * 请求与保持条件：⼀个进程因请求资源⽽阻塞时，对已获得的资源保持不放。
   * 不剥夺条件:线程已获得的资源在末使⽤完之前不能被其他线程强⾏剥夺，只有⾃⼰使⽤完毕 后才释放资源。
   * 循环等待条件:若⼲进程之间形成⼀种头尾相接的循环等待资源关系。
10. 线程start()与run()的区别。run()是实际业务逻辑，start()是让线程去干活，至于什么时候run什么时候等待那是多线程调度的事情。
11. synchronized *  
   synchronized 关键字可以保证 被它修饰的⽅法或者代码块在任意时刻只能有⼀个线程执⾏。  
   * 修饰实例⽅法: 作⽤于当前对象实例加锁，进⼊同步代码前要获得 当前对象实例的锁
   * 修饰静态⽅法: 也就是给当前类加锁，会作⽤于类的所有对象实例 ，进⼊同步代码前要获得 当前 class 的锁。static 表明这是该类的⼀个 静态资源，不管 new 了多少个对象，只有⼀份  
   * 修饰代码块：指定加锁对象，对给定对象/类加锁。 synchronized(this|object) 表示进⼊同步代码块前要获得给定对象的锁。 synchronized(.class) 表示进⼊同步代码前要获得 当前 class 的锁
12. 双重检验锁实现单例模式。  
    volatile 防止jvm指令重排、保证变量的可⻅性
13. CPU缓存与内存缓存。
14. JMM（java内存模型） 线程将变量在本地内存制作一个副本，对于共享变量可以使用volatile关键字使得每次都到主存中读取。
15. 如果你创建了⼀个 ThreadLocal 变量，那么访问这个变量的每个线程都会有这个变量的本地副本。
16. 线程池
   * 降低资源消耗。通过重复利⽤已创建的线程降低线程创建和销毁造成的消耗。 
   * 提⾼响应速度。当任务到达时，任务可以不需要的等到线程创建就能⽴即执⾏。 
   * 提⾼线程的可管理性。线程是稀缺资源，如果⽆限制的创建，不仅会消耗系统资源，还会降低系统的稳定性，使⽤线程池可以进⾏统⼀的分配，调优和监控。
17. Runnable是void、Callable有返回值和异常。都采用Thread.start()启动线程
18. void execute()，Future submit()
19. 创建线程池 ThreadPoolExecutor   
   corePoolSize、maximumPoolSize、workQueue
20. Atomic 原⼦类
   * JUC下的4类原子类 CAS ABA
   * AQS
21. CountDownLatch

# JVM
1. 公用：堆、元空间；私有：虚拟机栈、本地方法栈、程序计数器
2. 程序计数器：各线程独立拥有，可以看作是当前线程所执⾏的字节码的⾏号指示器。字节码 解释器⼯作时通过改变这个计数器的值来选取下⼀条需要执⾏的字节码指令，分⽀、循环、跳 转、异常处理、线程恢复等功能都需要依赖这个计数器来完成。
3. 虚拟机栈：Java 虚拟机栈是由⼀个个栈帧组成，⽽每个 栈帧中都拥有：局部变量表、操作数栈、动态链接、⽅法出⼝信息。局部变量表主要存放了编译期可知的各种数据类型（八种基础类型）、对象引用。
4. 本地⽅法栈：native版虚拟机栈
5. 方法区：各个线程共享，⽤于存储已被虚拟机加载的类信息、常 量、静态变量、即时编译器编译后的代码等数据。永生代是方法区的一种实现，1.7时存放在堆中；后面1.8在堆中删除了永生代，放到了直接内存里，称为元空间。
6. 常量池：
   * JDK1.8 hotspot移除了永久代⽤元空间(Metaspace)取⽽代之, 这时候字符串常量池还在堆, 运⾏时常量池还在⽅法区, 只不过⽅法区的实现从永久代变成了元空间
   * 静态常量池：就是.class文件
   * 运行时常量池 ：将静态.class文件加载到内存中之后的区域，属于方法区，典型为字符串常量池。
7. 堆：新生代、老生代、永生代（1.8删去） ***（回头再找个详细的看一下）***  
   新生代：Eden、From Survivor0(From/s0)、To Survivor1(To/s1) 
   老年代：Old Memory  
8. 堆的内存分配策略  
   * 优先在Eden分配，大对象直接老年代
   * 一次新生代GC后，还存活则进s0或s1
   * 每MinorGC一次，年龄增加1岁，达到阈值（最大值15岁）进入老年代
   * 关于阈值MaxTenuringThreshold：当累积的某个年龄⼤⼩超过了 survivor 区的⼀半时，取这个年龄和 MaxTenuringThreshold 中更⼩的⼀个值，作为新的晋升年龄阈值。Oracle的jdk根据垃圾收集器来规定，CMS是6.
9. GC分类  
   * 新⽣代收集（Minor GC / Young GC）：只对新⽣代进⾏。当eden区快满时触发。 
   * ⽼年代收集（Major GC / Old GC）：只对⽼年代进⾏。需要注意的是 Major GC 在有的语境中也⽤于指代整堆收集。（只有CMS的concurrent collection是这个模式）
   * 混合收集（Mixed GC）：对整个新⽣代和部分⽼年代进⾏垃圾收集。（只有G1有这个模式）
   * 整堆收集 (Full GC)：收集整个 Java 堆和⽅法区。在准备出发young GC时，发现晋升大小比老年代的剩余大小大，改为触发full gc。
10. 判断对象死亡  
   * 引用计数法
   * 可达性分析算法
11. 判断常量废弃  
    没有任何对象引用该常量
12. 判断类无用  
   * 该类所有的实例都已经被回收
   * 加载该类的 ClassLoader 已经被回收
   * 该类对应的 java.lang.Class 对象没有在任何地⽅被引⽤，⽆法在任何地⽅通过反射访问该类的⽅法。
13. GC算法
   * 标记清除：标记出不需要回收的对象，之后统一清除没有标记的。效率不高、碎片多。
   * 复制收集：内存分相同两块，优先一块，用完就把活的复制到另一块，然后把此块全部清理。（新生代）
   * 标记整理：先标记，然后将活着的向一端移动，最后把端边界以外内存全部清除。（老年代）
   * 分代收集：新生代使用复制因为死的多；老年代用标记清除或标记整理因为活的多
14. 垃圾回收器
   * Serial 收集器：串行，单线程，且必须暂停其他工作线程。新⽣代复制，⽼年代标记-整理。
   * ParNew 收集器：serial的多线程版本。只有它可以和CMS合作。新⽣代复制，⽼年代标记-整理。
   * Parallel Scavenge 收集器：专注于吞吐量，CPU 中⽤于运⾏⽤户代码的时间与 CPU 总消耗时间的⽐值，可手动/自动调节参数。jdk1.8默认。新⽣代复制，⽼年代标记-整理。
   * Serial Old 收集器：对应老年代版本。
   * Parallel Old 收集器：对应老年代版本。
   * CMS 收集器：目的为获取最短回收停顿时间，注重用户体验，第⼀次实现了让垃圾收集线程与⽤户线程（基本上）同时⼯作。初始标记(pause)、并发标记、重新标记(pause)、并发清除。标记-清除。并发收集、低停顿。对cpu敏感、无法处理浮动垃圾、标记清除会有大量碎片。
   * G1 收集器：⾯向服务器，主要针对配备多颗处理器及⼤容量内存的机器。以极⾼概率满⾜GC停顿时间要求的同时，还具备⾼吞吐量性能特征。初始标记、并发标记、最终标记、筛选回收。维护了一个优先列表，每次根据允许的收集时间，优先选择回收价值最⼤的 Region。
   * ZGC 收集器：与 CMS 中的 ParNew 和 G1 类似，ZGC 也采⽤标记-复制算法。
15. 引用分类
   * 强引用：创建一个对象并赋给一个引用。永远不会被gc，宁愿OOM。结束可以通过 a = null 来实现。
   * 软引用：SoftReference sr = new SoftReference(某强引用a)。内存足则不gc，不足则gc。
   * 弱引用：只具有弱引⽤的对象拥有更短暂的⽣命周期。在垃圾回收器线程扫描它所管辖的内存区域的过程中，⼀旦发现了只具有弱引⽤的对象，不管当前内存空间⾜够与否，都会回收它的内存。不过， 由于垃圾回收器是⼀个优先级很低的线程，因此不⼀定会很快发现那些只具有弱引⽤的对象。
   * 虚引用：要⽤来跟踪对象被垃圾回收的活动。
   在程序设计中⼀般很少使⽤弱引⽤与虚引⽤，使⽤软引⽤的情况较多，这是因为软引⽤可以加速JVM对垃圾内存的回收速度，可以维护系统的运⾏安全，防⽌内存溢出。
15. java对象创建过程
   * 类加载检查，遇到new先去看有没有加载过这个类，否，那先进行类加载
   * 分配内存，指针碰撞或空闲列表
   * 初始化零值
   * 设置对象头
   * 执行init方法
11. 对象访问定位方式：句柄、直接指针
   * 句柄（引用）：堆上划出一块句柄池，引用指向句柄，句柄指向实例（堆）与对象类型数据（方法区）
   * 直接指针：引用直接指向堆中实例，堆来考虑如何放置访问类型数据信息

# 计算机网络
1. OSI七层，TCP/IP四层
2. session保存在服务器端，cookie保存在客户端


# 数据结构
1. dp
   * 定义f(i)含义；
   * 找到f(i)与f(i-1)的状态转移方程；
   * 确定初始条件f(0)。
2. dfs
   ```java
   void dfs(TreeNode root) {
      if (root == null) {
         return;
      }
      dfs(root.left);
      dfs(root.right);
   }
   ```
3. bfs
   ```java
   void bfs(TreeNode root) {
        Queue<TreeNode> queue = new ArrayDeque<>();
        queue.add(root);
        while (!queue.isEmpty()) {
            TreeNode node = queue.poll(); // Java 的 pop 写作 poll()
            if (node.left != null) {
                queue.add(node.left);
            }
            if (node.right != null) {
                queue.add(node.right);
            }
        }
    }
   ```
4. a